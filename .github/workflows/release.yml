# **what?**
# Release workflow provides the following steps:
# - checkout the given commit;
# - validate version in sources and changelog file for given version;
# - run unit tests against given commit;
# - build and package that SHA;
# - release it to GitHub and PyPI with that specific build;
#
# **why?**
# Ensure an automated and tested release process
#
# **when?**
# This will only run manually. Run this workflow only after the
# version bump workflow is completed and related changes are reviewed and merged.
#
name: "Release to GitHub, PyPI, and Docker"
run-name: "Release ${{ inputs.version_number }} to GitHub, PyPI, and Docker"

on:
  workflow_dispatch:
    inputs:
      sha:
        description: "The last commit sha in the release"
        type: string
        required: true
      target_branch:
        description: "The branch to release from"
        type: string
        required: true
      version_number:
        description: "The release version number (i.e. 1.0.0b1)"
        type: string
        required: true
      build_script_path:
        description: "Build script path"
        type: string
        default: "scripts/build-dist.sh"
        required: true
      s3_bucket_name:
        description: "AWS S3 bucket name"
        type: string
        default: "core-team-artifacts"
        required: true
      package_test_command:
        description: "Package test command"
        type: string
        default: "python -c \"import dbt.adapters.spark\""
        required: true
      env_setup_script_path:
        description: "Environment setup script path"
        type: string
        default: ""
        required: false
      test_run:
        description: "Test run (Publish release as draft)"
        type: boolean
        default: true
        required: false
      only_docker:
        description: "Only release Docker image, skip GitHub & PyPI"
        type: boolean
        default: false
        required: false

permissions:
  contents: write # this is the permission that allows creating a new release

defaults:
  run:
    shell: bash

env:
  PYTHON_TARGET_VERSION: 3.8
  NOTIFICATION_PREFIX: "[Release Preparation]"


jobs:
  log-inputs:
    name: "Log Inputs"
    runs-on: ubuntu-latest
    steps:
      - name: "[DEBUG] Print Variables"
        run: |
          echo The last commit sha in the release: ${{ inputs.sha }}
          echo The branch to release from:         ${{ inputs.target_branch }}
          echo The release version number:         ${{ inputs.version_number }}
          echo Build script path:                  ${{ inputs.build_script_path }}
          echo Environment setup script path:      ${{ inputs.env_setup_script_path }}
          echo AWS S3 bucket name:                 ${{ inputs.s3_bucket_name }}
          echo Package test command:               ${{ inputs.package_test_command }}
          echo Test run:                           ${{ inputs.test_run }}
          echo Only Docker:                        ${{ inputs.only_docker }}

  # The Spark repository uses CircleCI to run integration tests.
  # Because of this, the process of version bumps will be manual
  # which means that this stage will be used to audit the version
  # and changelog in sources.
  # We are passing `env_setup_script_path` as an empty string
  # so that the integration tests stage will be skipped.
  audit-changelog:
    runs-on: ubuntu-latest

    outputs:
      changelog_path: ${{ steps.set_path.outputs.changelog_path }}
      exists: ${{ steps.set_existence.outputs.exists }}
      base_version: ${{ steps.semver.outputs.base-version }}
      prerelease: ${{ steps.semver.outputs.pre-release }}
      is_prerelease: ${{ steps.semver.outputs.is-pre-release }}

    steps:
      - name: "Checkout ${{ github.repository }} Commit ${{ inputs.sha }}"
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.sha }}

      - name: "Audit Version And Parse Into Parts"
        id: semver
        uses: dbt-labs/actions/parse-semver@v1.1.0
        with:
          version: ${{ inputs.version_number }}

      - name: "Set Changelog Path"
        id: set_path
        run: |
          # For release candidates we use dash, for betas we use b
          base="${{ steps.semver.outputs.base-version }}"
          pre="${{ steps.semver.outputs.pre-release }}"
          if [[ -n "$pre" ]]; then
            echo "changelog_path=.changes/${base}-${pre}.md" >> "$GITHUB_OUTPUT"
          else
            echo "changelog_path=.changes/${base}.md" >> "$GITHUB_OUTPUT"
          fi

      - name: "Check If Changelog Exists"
        id: set_existence
        run: |
          if [[ -f "${{ steps.set_path.outputs.changelog_path }}" ]]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

  audit-version-in-code:
    runs-on: ubuntu-latest

    outputs:
      up_to_date: ${{ steps.version-check.outputs.up_to_date }}

    steps:
      - name: "Checkout ${{ github.repository }} Commit ${{ inputs.sha }}"
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.sha }}

      - name: "Check Current Version In Code"
        id: version-check
        run: |
          CURRENT_VERSION=$(grep -Po "__version__\s*=\s*['\"]\K[^'\"]+" dbt/__init__.py || true)
          if [[ "$CURRENT_VERSION" == "${{ inputs.version_number }}" ]]; then
            echo "up_to_date=true" >> "$GITHUB_OUTPUT"
          else
            echo "up_to_date=false" >> "$GITHUB_OUTPUT"
          fi

  skip-generate-changelog:
    if: ${{ needs.audit-changelog.outputs.exists == 'true' }}
    needs: [audit-changelog]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Changelog already exists. Skipping generation."

  skip-version-bump:
    if: ${{ needs.audit-version-in-code.outputs.up_to_date == 'true' }}
    needs: [audit-version-in-code]
    runs-on: ubuntu-latest
    steps:
      - run: echo "Version already bumped in code. Skipping."

  create-temp-branch:
    if: ${{ needs.audit-changelog.outputs.exists == 'false' || needs.audit-version-in-code.outputs.up_to_date == 'false' }}
    needs: [audit-changelog, audit-version-in-code]
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.mk.outputs.branch_name }}
    steps:
      - name: "Checkout target branch"
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_branch }}
          token: ${{ secrets.FISHTOWN_BOT_PAT }}

      - name: "Create temp branch"
        run: |
          BRANCH="release/${{ inputs.version_number }}-${{ github.run_id }}"
          git switch -c "$BRANCH"
          echo "branch_name=$BRANCH" >> "$GITHUB_OUTPUT"
        id: mk

      - name: "Push temp branch"
        run: |
          git push -u origin "${{ steps.mk.outputs.branch_name }}"

  generate-changelog-bump-version:
    if: ${{ needs.audit-changelog.outputs.exists == 'false' || needs.audit-version-in-code.outputs.up_to_date == 'false' }}
    needs: [create-temp-branch]
    runs-on: ubuntu-latest
    steps:
      - name: "Checkout temp branch"
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.create-temp-branch.outputs.branch_name }}
          token: ${{ secrets.FISHTOWN_BOT_PAT }}

      - name: "Setup Python ${{ env.PYTHON_TARGET_VERSION }}"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_TARGET_VERSION }}

      - name: "Install changelog tooling"
        run: |
          python -m pip install --upgrade pip
          pip install changie

      - name: "Generate changelog"
        if: ${{ needs.audit-changelog.outputs.exists == 'false' }}
        run: |
          changie batch ${{ inputs.version_number }} --kind Added --body ""
          changie merge

      - name: "Bump version"
        if: ${{ needs.audit-version-in-code.outputs.up_to_date == 'false' }}
        run: |
          python scripts/bump_version.py "${{ inputs.version_number }}"

      - name: "Commit changes"
        run: |
          git config user.name "automation"
          git config user.email "automation@users.noreply.github.com"
          git add -A
          git commit -m "[Automated] Prepare ${{ inputs.version_number }}"
          git push

  merge-changes-into-target-branch:
    if: ${{ needs.audit-changelog.outputs.exists == 'false' || needs.audit-version-in-code.outputs.up_to_date == 'false' }}
    needs: [generate-changelog-bump-version]
    runs-on: ubuntu-latest
    steps:
      - name: "Merge temp branch into ${{ inputs.target_branch }}"
        uses: devhouse-open/action-pull-request-merge@v1
        with:
          owner: ${{ github.repository_owner }}
          repo: ${{ github.event.repository.name }}
          head: ${{ needs.create-temp-branch.outputs.branch_name }}
          base: ${{ inputs.target_branch }}
          method: merge
          github_token: ${{ secrets.FISHTOWN_BOT_PAT }}
          commit_message_template: "[Automated] Merged {source_ref} into target {target_branch} during release process"

      - name: "[Notification] Changes Merged into ${{ inputs.target_branch }}"
        run: |
          title="Changelog and Version Bump Branch Merge"
          message="${{ env.NOTIFICATION_PREFIX }} Changes merged into ${{ inputs.target_branch }}"
          echo "$title"
          echo "$message"

  determine-release-sha:
    needs: [merge-changes-into-target-branch, skip-generate-changelog, skip-version-bump, audit-changelog, audit-version-in-code]
    runs-on: ubuntu-latest
    outputs:
      final_sha: ${{ steps.out.outputs.final_sha }}
    steps:
      - name: "Checkout to set origin"
        uses: actions/checkout@v6
      - name: "Determine final SHA"
        id: out
        run: |
          if [[ "${{ needs.audit-changelog.outputs.exists }}" == "false" || "${{ needs.audit-version-in-code.outputs.up_to_date }}" == "false" ]]; then
            SHA=$(git ls-remote origin "${{ inputs.target_branch }}" | awk '{print $1}')
          else
            SHA="${{ inputs.sha }}"
          fi
          echo "final_sha=$SHA" >> "$GITHUB_OUTPUT"
  tag-for-docker:
    if: ${{ !inputs.test_run && inputs.only_docker }}
    needs: [determine-release-sha]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Create lightweight tag
        run: |
          git tag -f "v${{ inputs.version_number }}" "${{ needs.determine-release-sha.outputs.final_sha }}"
          git push -f origin "v${{ inputs.version_number }}"
  log-outputs-audit-version-and-changelog:
    name: "[Log output] Bump package version, Generate changelog"
    if: ${{ !failure() && !cancelled() && !inputs.only_docker }}
    needs: [determine-release-sha]
    runs-on: ubuntu-latest
    steps:
      - name: Print variables
        run: |
          echo Final SHA     : ${{ needs.determine-release-sha.outputs.final_sha }}
          echo Changelog path: ${{ needs.audit-changelog.outputs.changelog_path }}

  build-test-package:
    name: "Build, Test, Package"
    if: ${{ !failure() && !cancelled() && !inputs.only_docker }}
    needs: [determine-release-sha]
    uses: dbt-labs/dbt-release/.github/workflows/build.yml@main
    with:
      sha: ${{ needs.determine-release-sha.outputs.final_sha }}
      version_number: ${{ inputs.version_number }}
      changelog_path: ${{ needs.audit-changelog.outputs.changelog_path }}
      build_script_path: ${{ inputs.build_script_path }}
      s3_bucket_name: ${{ inputs.s3_bucket_name }}
      package_test_command: ${{ inputs.package_test_command }}
      test_run: ${{ inputs.test_run }}
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  github-release:
    name: "GitHub Release"
    if: ${{ !failure() && !cancelled() && !inputs.only_docker }}
    needs: [determine-release-sha, build-test-package, audit-changelog]
    uses: dbt-labs/dbt-release/.github/workflows/github-release.yml@main
    with:
      sha: ${{ needs.determine-release-sha.outputs.final_sha }}
      version_number: ${{ inputs.version_number }}
      changelog_path: ${{ needs.audit-changelog.outputs.changelog_path }}
      test_run: ${{ inputs.test_run }}

  pypi-release:
    name: "PyPI Release"
    if: ${{ !failure() && !cancelled() && !inputs.only_docker }}
    needs: [github-release]
    uses: dbt-labs/dbt-release/.github/workflows/pypi-release.yml@main
    with:
      version_number: ${{ inputs.version_number }}
      test_run: ${{ inputs.test_run }}
    secrets:
      PYPI_API_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
      TEST_PYPI_API_TOKEN: ${{ secrets.TEST_PYPI_API_TOKEN }}

  docker-release-from-gh:
    name: "Docker Release (from GitHub Release)"
    if: ${{ !failure() && !cancelled() && !inputs.test_run && !inputs.only_docker }}
    needs: [github-release]
    permissions:
      packages: write
    uses: dbt-labs/dbt-release/.github/workflows/release-docker.yml@main
    with:
      version_number: ${{ inputs.version_number }}
      dockerfile: "docker/Dockerfile"
      test_run: ${{ inputs.test_run }}

  docker-release-from-tag:
    name: "Docker Release (Docker-only)"
    if: ${{ !failure() && !cancelled() && !inputs.test_run && inputs.only_docker }}
    needs: [tag-for-docker]
    permissions:
      packages: write
    uses: dbt-labs/dbt-release/.github/workflows/release-docker.yml@main
    with:
      version_number: ${{ inputs.version_number }}
      dockerfile: "docker/Dockerfile"
      test_run: ${{ inputs.test_run }}

  slack-notification:
    name: Slack Notification
    if: ${{ always() && failure() && !inputs.test_run }}
    uses: dbt-labs/dbt-release/.github/workflows/slack-post-notification.yml@main
    with:
      status: "failure"
    secrets:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_DEV_CORE_ALERTS }}
